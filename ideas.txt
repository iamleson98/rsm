/*
goals
1. learn, have fun -- simlicity
2. substrate, a thing to make other thing on
3. longevity -- I want to be able to run a (multimedia) program in 10+ years

- embraces the linear memory model
- simple semantics:
  - global constants
  - mutable locals (parameters and variables)
  - vm uses registers but user doesn't need to specify (automatic regalloc)
- simple syntax where whitespace is ignored:
    fundef = "fun" name "(" params? ")" result? LF
    params = name type ("," name type)*
    result = type ("," type)*
    type   = i1 | i8 | i16 | i32 | i64
           | u1 | u8 | u16 | u32 | u64 | addr
           | f32 | f64 | f128
    instr  = [reg "="] op arg*
*/

fun hello () i32
  one = i32 1
  two = i32 2
  r = one + two
  ret

/*
int factorial(int n) {
  if (n == 0) return 1;
  else        return n * factorial(n-1);
}

define i32 @factorial(i32 %0) local_unnamed_addr #0 {
  br label %2
2:  ; preds = %6, %1
  %3 = phi i32 [ 1, %1 ], [ %8, %6 ]
  %4 = phi i32 [ %0, %1 ], [ %7, %6 ]
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %9, label %6
6:  ; preds = %2
  %7 = add nsw i32 %4, -1
  %8 = mul nsw i32 %4, %3
  br label %2
9:  ; preds = %2
  ret i32 %3
}

factorial:
  mov  x8, x0
  mov  w0, #1
  cbz  w8, LBB0_2  ; Compare and Branch on Zero
LBB0_1:
  mul  w0, w8, w0
  sub  w8, w8, #1 ; =1
  cbnz w8, LBB0_1  ; Compare and Branch on Nonzero
LBB0_2:
  ret
*/

// br LABEL       -- goto LABEL
// br VALUE       -- goto address loaded from VALUE
// br VALUE LABEL -- goto LABEL if VALUE!=0
// br VALUE L1 L2 -- goto L1 if VALUE!=0, goto L2 if VALUE==0

// register style
fun factorial (i32) i32
  b0:              //
    r8 = r0        // ACC = n (n is in r0, argument 0)
    r0 = 1         // RES (return value 0)
    ifz r8 end     // if n==0 goto end
  b1:              // <- [b0] b1  ("[b]=implicit/fallthrough")
    r0 = mul r8 r0 // RES = ACC * RES
    r8 = sub r8 1  // ACC = ACC - 1
    ifnz r8 b1     // if n!=0 goto b1
  end:             // <- b0 [b1]
    ret            // RES is at r0

// SSA style
fun factorial (n i32) i32
  b0:
    br b1                        // continue to b1
  b1:                            // -- b1 <- b0 b2
    RES1 = phi (b0 1) (b2 RES2)  // init RES1 = 1 (else RES1 = RES2)
    ACC1 = phi (b0 n) (b2 ACC2)  // init ACC1 = n (else ACC1 = ACC2)
    c = cmpeq ACC1 0             // if ACC1 == 0 ...
    br c end b2                  // ... goto end else continue to b2
  b2:                            // -- b2 <- b1
    ACC2 = sub ACC1 1            // ACC2 = ACC1 - 1
    RES2 = mul ACC1 RES1         // RES2 = ACC1 * RES2
    br b1                        // goto b1
  end:                           // -- end <- b1
    ret RES1

// locals style
fun factorial (n i32) i32
  var ACC i32         // accumulator
  var RES i32         // result
  b0:                 //
    ifz n end         // if n==0 goto end
    ACC = n           // initialize ACC to n
    RES = 1           // initialize RES to 1
  b1:                 // <- [b0] b1  ("[b]=implicit/fallthrough")
    RES = mul ACC RES // RES = ACC * RES
    ACC = sub ACC 1   // ACC = ACC - 1
    ifnz ACC b1       // if n!=0 goto b1
  end:                // <- b0 [b1]
    ret RES




// —————————————————————————————————————————————————

// device/memory hybrid
//
// screen framebuffer memory layout:
//   Byte   Type  Use
//   ────── ───── ──────────────────────────────────────
//   0…7    addr  event hook address
//   8…11   u32   x resolution (number of pixels)
//   12…15  u32   y resolution
//   16…    u32   x*y*4 bytes of pixel values (8-bit RGBA)
//
//   X  0  1  2  3  4  5  6  7
// Y ┌────────────────────────
// 0 │  0  1  2  3  4  5  6  7
// 1 │  8  9 10 11 12 13 14 15
// 2 │ 16 17 18 19 20 21 22 23
// 3 │ 24 25 26 27 28 29 30 31
// 4 │ 32 33 34 35 36 37 38 39
// 5 │ 40 41 42 43 44 45 46 47
// 6 │ 48 49 50 51 52 53 54 55
// 7 │ 56 57 58 59 60 61 62 63
//
// ADDR = devopen  DEVKIND DEVNO
// OK   = devclose ADDR
// V    = load     TYPE ADDR [ADDROFFS]
//        store    V ADDR [ADDROFFS]
fun draw_solid_color (color i32) -> () {
  const DEV_SCREEN = 0
  var x, y, w, h i32
  var fb, px addr
  fb = devopen DEV_SCREEN 0 // load screen device #0
  ifz fb end                // if 0 then error
  w = load i32 fb 8
  h = load i32 fb 12
  x = 0
  y = 0
draw:
  // pixel address = fb + w*y + x + 16
  px = mul w y
  px = add px x
  px = add px fb
  store color px 16 // pixels are at byte offset 16
  x = add x 1
  ifneq x w draw // while x < w, keep drawing
  // x == w; reset x and advance y
  x = 0
  y = add y 1
  ifneq y h draw
  // done
  devclose fb
end:
  ret
}


// memory-mapped screen
//
// screen device memory layout:
//   Byte   Type  Use
//   ────── ───── ──────────────────────────────────────
//   0…7    addr  event hook address
//   8…11   u32   x resolution (number of pixels)
//   12…15  u32   y resolution
//   16…23  addr  framebuffer address; array of x*y pixel values (8-bit RGBA)
//
fun draw_solid_color (color i32) -> () {
  const SCREEN = 0xffffffffffff
  var x, y, w, h i32
  var px, fb i64
  x = 0
  y = 0
  w = load SCREEN 8
  h = load SCREEN 12
  fb = load SCREEN 16
draw:
  px = mul w y   // pixel address = fb[w*y + x]
  px = add px x
  store color fb px
  x = add x 1
  ifneq x w draw // while x < w, keep drawing
  // x == w; reset x and advance y
  x = 0
  y = add y 1
  ifneq y h draw
end:
  ret
}


const SC_OPEN = 1
const SC_CLOSE = 2
const SC_READ = 3
const SC_WRITE = 4
const FD_STDOUT = 1

fun hello () -> () {
  const MESSAGE = "hello\n"
  syscall SC_WRITE FD_STDOUT MESSAGE 6
  ret
}

fun cat (filename addr) -> () {
  const BUFSIZE = 4096
  var fd, n int
  var buf addr
  // allocate buffer
  buf = memalloc 1 BUFSIZE  // align 1B
  ifz buf end
  // open file
  fd = syscall SC_OPEN filename 0  // 0 = read-only mode
  iflt fd 0 end_freebuf
read:
  n = syscall SC_READ fd buf BUFSIZE
  syscall SC_WRITE FD_STDOUT buf n
  ifeq n BUFSIZE read // if n == BUFSIZE goto read
  syscall CLOSE fd
end_freebuf:
  memfree buf
end:
  ret
}



// instructions:
//   FD   = open     ADDR FLAGS
//   OK   = close    FD
//   N    = read     FD DSTADDR LEN
//   N    = write    FD SRCADDR LEN
//   N    = readat   FD DSTADDR OFFS LEN
//   N    = writeat  FD SRCADDR OFFS LEN
//   ADDR = memalloc NPAGES FLAGS
//   void = memfree  ADDR
const FD_STDOUT = 1

fun hello () -> () {
  const MESSAGE = "hello\n"
  write FD_STDOUT MESSAGE 6
  ret
}

fun cat (filename addr) -> () {
  const BUFSIZE = 4096  // page size
  var fd, n int
  var buf addr
  // allocate buffer
  buf = memalloc 1 1    // one page, flags=read+write
  ifz buf end
  // open file
  fd = open filename 0  // 0 = read-only mode
  iflt fd 0 end_freebuf
read:
  n = read fd buf BUFSIZE
  write FD_STDOUT buf n
  ifeq n BUFSIZE read   // if n == BUFSIZE goto read
  close fd
end_freebuf:
  memfree buf
end:
  ret
}


// file-oriented
//
// FD = fopen    ADDR FLAGS
// OK = fclose   FD
// N  = fread    FD DSTADDR LEN
// N  = fwrite   FD SRCADDR LEN
// N  = freadat  FD DSTADDR OFFS LEN
// N  = fwriteat FD SRCADDR OFFS LEN
//
fun draw_solid_color (COLOR i32) -> (status i32) {
  const DEV_SCREEN0 = 0xff  // special address of screen device #0
  var X, Y, W, H, SCREEN, OFFS i32
  init:
    X = 0
    Y = 0
    SCREEN = fopen DEV_SCREEN0 2 // flags = read+write
    iflt SCREEN 0 end            // end if there's no screen device
    freadat SCREEN &W 4 4        // width at offset 4
    freadat SCREEN &H 8 4        // height at offset 8
  draw:
    OFFS = mul W Y     // pixel offset = 16 + (w*y) + x
    OFFS = add OFFS X
    OFFS = add OFFS 16 // pixel array at offset 16 in screen device
    fwriteat SCREEN &COLOR 16 4
    X = add X 1
    ifneq X W draw // while X < W, keep drawing
    // X == W; reset X and advance Y
    X = 0
    Y = add Y 1
    ifneq Y H draw
    // done
    fclose SCREEN
    SCREEN = 0
  end:
    STATUS = SCREEN // return error value from devopen (or 0 on success)
    ret
}


// device-oriented
//
// HANDLE = devopen DEVID [ARG1 [ARG2 [ARG2]]]
// VALUE  = devload HANDLE OFFSET
//          devstore HANDLE OFFSET VALUE
//
fun draw_solid_color (COLOR i32) -> (STATUS i32) {
  const kDevScreen = 1
  var X, Y, W, H, SCREEN, OFFS i32
  init:
    X = 0
    Y = 0
    SCREEN = devopen kDevScreen 0
    iflt SCREEN 0 end    // end if there's no screen device
    W = devload SCREEN 4 // width at offset 4
    H = devload SCREEN 8 // height at offset 8
  draw:
    OFFS = mul W Y     // pixel offset = 16 + (w*y) + x
    OFFS = add OFFS X
    OFFS = add OFFS 16 // pixel array at offset 16 in screen device
    devstore SCREEN OFFS COLOR
    X = add X 1
    ifneq X W draw // while X < W, keep drawing
    // X == W; reset X and advance Y
    X = 0
    Y = add Y 1
    ifneq Y H draw
    // else zero SCREEN and exit
    SCREEN = 0
  end:
    STATUS = SCREEN // return error value from devopen (or 0 on success)
    ret
}

// ...
ok = call draw_solid_color 0xff00ffff // RGBA


//   X  0  1  2  3  4  5  6  7
// Y ┌────────────────────────
// 0 │  0  1  2  3  4  5  6  7
// 1 │  8  9 10 11 12 13 14 15
// 2 │ 16 17 18 19 20 21 22 23
// 3 │ 24 25 26 27 28 29 30 31
// 4 │ 32 33 34 35 36 37 38 39
// 5 │ 40 41 42 43 44 45 46 47
// 6 │ 48 49 50 51 52 53 54 55
// 7 │ 56 57 58 59 60 61 62 63
//
// pixel offset = 16 + (w*y) + x



// /dev/screen ioctl constants
const kScreenGetXRes = 1
const kScreenGetYRes = 2
const kScreenSetPixel = 3

fun draw_solid_color (COLOR i32) i32
  var X, Y, W, H, SCREEN, R i32
  init:
    X = 0
    Y = 0
    R = open "/dev/screen0"
    iflt R 0 end
    SCREEN = R
    R = ioctl SCREEN kScreenGetXRes
    iflt R 0 end
    W = R
    R = ioctl SCREEN kScreenGetYRes
    iflt R 0 end
    H = R
  draw:
    R = ioctl SCREEN kScreenSetPixel X Y COLOR
    iflt R 0 end
    X = add X 1
    ifneq X W draw // while X < W, keep drawing
    // X == W; reset X and advance Y
    X = 0
    Y = add Y 1
    ifneq Y H draw
    // else end
  end:
    ret R

// ...
ok = call draw_solid_color 0xff00ffff // RGBA


// ----
// what if there's implicit error handling?

fun draw_solid_color (COLOR i32) i32
  var X, Y, W, H, SCREEN i32
  init:
    X = 0
    Y = 0
    SCREEN = open "/dev/screen0"    // jumps to label named "error" on failure
    W = ioctl SCREEN kScreenGetXRes // --||--
    H = ioctl SCREEN kScreenGetYRes
  draw:
    _ = ioctl SCREEN kScreenSetPixel X Y COLOR
    X = add X 1
    ifneq X W draw // while X < W, keep drawing
    // X == W; reset X and advance Y
    X = 0
    Y = add Y 1
    ifneq Y H draw
    // else end
  error: // special label name
    ret



fun hello () -> () {
  const DEV_CONSOLE = 0
  var console addr
  console = devopen DEV_CONSOLE 0
  ifz console end
  store 'h' console
  store 'e' console
  store 'l' console
  store 'l' console
  store 'o' console
  store '\n' console
  devclose console
end:
  ret
}

const OPEN = 1
const CLOSE = 2
const READ = 3
const WRITE = 4
fun hello () -> () {
  const DEV_CONSOLE = "/dev/console"
  const MESSAGE = "hello\n"
  var fd int
  fd = syscall OPEN DEV_CONSOLE 0
  iflt fd 0 end
  syscall WRITE fd MESSAGE 6
  syscall CLOSE fd
end:
  ret
}
