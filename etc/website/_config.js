const fs = require("fs")
const os = require("os")
const assert = require("assert")

const rsm_h_file = os.homedir() + "/src/rsm/src/rsm.h"
const ops_json_file = "ops.json"

module.exports = ({
  site,     // mutable object describing the site
  hljs,     // HighlightJS module (NPM: highlight.js)
  markdown, // Markdown module (NPM: markdown-wasm)
  glob,     // glob function (NPM: miniglob)
  mtime,
  build_site,
  read_file,  // "node:fs/promises".readFile
  write_file, // "node:fs/promises".writeFile + mkdir if needed
}) => {
  // called when program starts
  //site.outdir = ".."
  // console.log(site)

  // configure highlight.js
  hljs.registerLanguage("rsm",    require("./_hl/rsm"))
  hljs.registerLanguage("asmarm", require("./_hl/armasm"))
  hljs.registerLanguage("asmx86", require("./_hl/x86asm"))
  hljs.registerLanguage("wast",   require("./_hl/wasm"))
  hljs.registerLanguage("bnf",    require("./_hl/abnf"))

  // ignore some source files
  let defaultIgnoreFilter = site.ignoreFilter
  site.ignoreFilter = (name, path) =>
    defaultIgnoreFilter.call(site, name, path) ||
    path == "build.sh"

  // don't rebuild when ops_json_file changes
  site.ignoreWatchFilter = (name, path) =>
    path == ops_json_file

  // these optional callbacks can return a Promise to cause build process to wait
  //
  site.onBeforeBuild = async (files) => {
    // called when .pages has been populated
    // console.log("onBeforeBuild pages:", site.pages)
    // console.log("onBeforeBuild files:", files)
    site.rsm_ops = await gen_rsm_ops(mtime, read_file, write_file)
  }

  // site.onAfterBuild = (files) => {
  //   // called after site has been generated
  //   // console.log("onAfterBuild")
  // }

  // rebuild when rsm_h_file changes
  if (fs.existsSync(rsm_h_file)) {
    let rebuild_timer = null
    fs.watch(rsm_h_file, {persistent:false}, (event, filename) => {
      clearTimeout(rebuild_timer)
      rebuild_timer = setTimeout(() => {
        if (mtime(rsm_h_file) > mtime(ops_json_file))
          build_site()
        rebuild_timer = null
      }, 50)
    })
  }
}


async function gen_rsm_ops(mtime, read_file, write_file) {
  console.log(`generate ${ops_json_file} from ${rsm_h_file}`)

  if (!fs.existsSync(rsm_h_file) || mtime(rsm_h_file) <= mtime(ops_json_file))
    return JSON.parse(fs.readFileSync(ops_json_file, {encoding:"utf8"}))

  let rsm_h = fs.readFileSync(rsm_h_file, {encoding:"utf8"})
  let ops = []

  let lines = rsm_h.trim().split("\n")
  let start_prefix = '#define RSM_FOREACH_OP('
  let i = find_line_with_prefix(lines, start_prefix)
  assert(i != -1, `no line with prefix "${start_prefix}"`)
  for (i++; i < lines.length; i++) {
    let line = lines[i].trim()
    if (line[0] != '_') {
      if (line[0] != '\\') // end
        break
      continue
    }
    // line = "_(name, arguments, result, asmname, semantics)"
    // e.g.
    //   _( COPY   , ABu  , reg , "copy"    /* RA = Bu -- aka "move" */)
    let re =
      /^_\(\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*("[^,\s]+")\s*,\s*(".*")\s*\)/
    let m = line.match(re)
    try {
      let [_, id, args, result, name, semantics] = m
      name = JSON.parse(name)
      semantics = JSON.parse(semantics)
      ops.push({id, args, result, name, semantics})
      //console.log({id, args, result, name, semantics})
    } catch (err) {
      console.error("offending line:\n" + line)
      console.error("line.match =>", m)
      throw err
    }
  }

  await Promise.all([
    write_file(ops_json_file, JSON.stringify(ops, null, "\t"), {encoding:"utf8"}),
  ].concat(
    ops.map(op => gen_rsm_op_page(op, mtime, read_file, write_file))
  ))
  return ops
}


async function gen_rsm_op_page(op, mtime, read_file, write_file) {
  let dstfile = "isa/op." + op.name + ".md"
  let curr_txt = ""
  if (mtime(dstfile) > 0) {
    curr_txt = await read_file(dstfile, "utf8")
    if (curr_txt.indexOf("x-autogenerated: true") == -1) {
      // don't touch customized page
      return
    }
  }
  let txt = `
---
title: ${op.name}
template: template-op
x-autogenerated: true
---

\`${op.name} ${op.args} â†’ ${op.result}\`

${op.semantics}
  `.trim() + "\n"
  if (txt != curr_txt) {
    console.log(`generate ${dstfile}`)
    await write_file(dstfile, txt, "utf8")
  }
}


function find_line_with_prefix(lines, prefix) {
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith('#define RSM_FOREACH_OP('))
      return i
  }
  return -1
}
